// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v4.25.1
// source: proto/controller.proto

package gen

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	NodeService_RegisterNode_FullMethodName     = "/controller.NodeService/RegisterNode"
	NodeService_StreamEvents_FullMethodName     = "/controller.NodeService/StreamEvents"
	NodeService_UpdateNodeStatus_FullMethodName = "/controller.NodeService/UpdateNodeStatus"
	NodeService_GetNodeConfig_FullMethodName    = "/controller.NodeService/GetNodeConfig"
)

// NodeServiceClient is the client API for NodeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Node Service - Handles node registration and communication
type NodeServiceClient interface {
	// Register a new node with the controller
	RegisterNode(ctx context.Context, in *RegisterNodeRequest, opts ...grpc.CallOption) (*RegisterNodeResponse, error)
	// Establish bidirectional streaming for events and commands
	StreamEvents(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[NodeEvent, ControllerCommand], error)
	// Update node status and metrics
	UpdateNodeStatus(ctx context.Context, in *UpdateNodeStatusRequest, opts ...grpc.CallOption) (*UpdateNodeStatusResponse, error)
	// Get node configuration from controller
	GetNodeConfig(ctx context.Context, in *GetNodeConfigRequest, opts ...grpc.CallOption) (*GetNodeConfigResponse, error)
}

type nodeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeServiceClient(cc grpc.ClientConnInterface) NodeServiceClient {
	return &nodeServiceClient{cc}
}

func (c *nodeServiceClient) RegisterNode(ctx context.Context, in *RegisterNodeRequest, opts ...grpc.CallOption) (*RegisterNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterNodeResponse)
	err := c.cc.Invoke(ctx, NodeService_RegisterNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) StreamEvents(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[NodeEvent, ControllerCommand], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &NodeService_ServiceDesc.Streams[0], NodeService_StreamEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[NodeEvent, ControllerCommand]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type NodeService_StreamEventsClient = grpc.BidiStreamingClient[NodeEvent, ControllerCommand]

func (c *nodeServiceClient) UpdateNodeStatus(ctx context.Context, in *UpdateNodeStatusRequest, opts ...grpc.CallOption) (*UpdateNodeStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateNodeStatusResponse)
	err := c.cc.Invoke(ctx, NodeService_UpdateNodeStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) GetNodeConfig(ctx context.Context, in *GetNodeConfigRequest, opts ...grpc.CallOption) (*GetNodeConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNodeConfigResponse)
	err := c.cc.Invoke(ctx, NodeService_GetNodeConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeServiceServer is the server API for NodeService service.
// All implementations must embed UnimplementedNodeServiceServer
// for forward compatibility.
//
// Node Service - Handles node registration and communication
type NodeServiceServer interface {
	// Register a new node with the controller
	RegisterNode(context.Context, *RegisterNodeRequest) (*RegisterNodeResponse, error)
	// Establish bidirectional streaming for events and commands
	StreamEvents(grpc.BidiStreamingServer[NodeEvent, ControllerCommand]) error
	// Update node status and metrics
	UpdateNodeStatus(context.Context, *UpdateNodeStatusRequest) (*UpdateNodeStatusResponse, error)
	// Get node configuration from controller
	GetNodeConfig(context.Context, *GetNodeConfigRequest) (*GetNodeConfigResponse, error)
	mustEmbedUnimplementedNodeServiceServer()
}

// UnimplementedNodeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNodeServiceServer struct{}

func (UnimplementedNodeServiceServer) RegisterNode(context.Context, *RegisterNodeRequest) (*RegisterNodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterNode not implemented")
}
func (UnimplementedNodeServiceServer) StreamEvents(grpc.BidiStreamingServer[NodeEvent, ControllerCommand]) error {
	return status.Error(codes.Unimplemented, "method StreamEvents not implemented")
}
func (UnimplementedNodeServiceServer) UpdateNodeStatus(context.Context, *UpdateNodeStatusRequest) (*UpdateNodeStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateNodeStatus not implemented")
}
func (UnimplementedNodeServiceServer) GetNodeConfig(context.Context, *GetNodeConfigRequest) (*GetNodeConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNodeConfig not implemented")
}
func (UnimplementedNodeServiceServer) mustEmbedUnimplementedNodeServiceServer() {}
func (UnimplementedNodeServiceServer) testEmbeddedByValue()                     {}

// UnsafeNodeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeServiceServer will
// result in compilation errors.
type UnsafeNodeServiceServer interface {
	mustEmbedUnimplementedNodeServiceServer()
}

func RegisterNodeServiceServer(s grpc.ServiceRegistrar, srv NodeServiceServer) {
	// If the following call panics, it indicates UnimplementedNodeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NodeService_ServiceDesc, srv)
}

func _NodeService_RegisterNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).RegisterNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_RegisterNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).RegisterNode(ctx, req.(*RegisterNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_StreamEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NodeServiceServer).StreamEvents(&grpc.GenericServerStream[NodeEvent, ControllerCommand]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type NodeService_StreamEventsServer = grpc.BidiStreamingServer[NodeEvent, ControllerCommand]

func _NodeService_UpdateNodeStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNodeStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).UpdateNodeStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_UpdateNodeStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).UpdateNodeStatus(ctx, req.(*UpdateNodeStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_GetNodeConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).GetNodeConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_GetNodeConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).GetNodeConfig(ctx, req.(*GetNodeConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeService_ServiceDesc is the grpc.ServiceDesc for NodeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "controller.NodeService",
	HandlerType: (*NodeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterNode",
			Handler:    _NodeService_RegisterNode_Handler,
		},
		{
			MethodName: "UpdateNodeStatus",
			Handler:    _NodeService_UpdateNodeStatus_Handler,
		},
		{
			MethodName: "GetNodeConfig",
			Handler:    _NodeService_GetNodeConfig_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamEvents",
			Handler:       _NodeService_StreamEvents_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "proto/controller.proto",
}

const (
	ServerService_CreateServer_FullMethodName     = "/controller.ServerService/CreateServer"
	ServerService_UpdateServer_FullMethodName     = "/controller.ServerService/UpdateServer"
	ServerService_DeleteServer_FullMethodName     = "/controller.ServerService/DeleteServer"
	ServerService_StartServer_FullMethodName      = "/controller.ServerService/StartServer"
	ServerService_StopServer_FullMethodName       = "/controller.ServerService/StopServer"
	ServerService_GetServerStatus_FullMethodName  = "/controller.ServerService/GetServerStatus"
	ServerService_StreamServerLogs_FullMethodName = "/controller.ServerService/StreamServerLogs"
)

// ServerServiceClient is the client API for ServerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Server Service - Handles game server lifecycle management
type ServerServiceClient interface {
	// Create a new game server on a node
	CreateServer(ctx context.Context, in *CreateServerRequest, opts ...grpc.CallOption) (*CreateServerResponse, error)
	// Update server configuration
	UpdateServer(ctx context.Context, in *UpdateServerRequest, opts ...grpc.CallOption) (*UpdateServerResponse, error)
	// Delete a server
	DeleteServer(ctx context.Context, in *DeleteServerRequest, opts ...grpc.CallOption) (*DeleteServerResponse, error)
	// Start a server
	StartServer(ctx context.Context, in *StartServerRequest, opts ...grpc.CallOption) (*StartServerResponse, error)
	// Stop a server
	StopServer(ctx context.Context, in *StopServerRequest, opts ...grpc.CallOption) (*StopServerResponse, error)
	// Get server current status
	GetServerStatus(ctx context.Context, in *GetServerStatusRequest, opts ...grpc.CallOption) (*GetServerStatusResponse, error)
	// Stream server logs in real-time
	StreamServerLogs(ctx context.Context, in *StreamLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogEntry], error)
}

type serverServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewServerServiceClient(cc grpc.ClientConnInterface) ServerServiceClient {
	return &serverServiceClient{cc}
}

func (c *serverServiceClient) CreateServer(ctx context.Context, in *CreateServerRequest, opts ...grpc.CallOption) (*CreateServerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateServerResponse)
	err := c.cc.Invoke(ctx, ServerService_CreateServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) UpdateServer(ctx context.Context, in *UpdateServerRequest, opts ...grpc.CallOption) (*UpdateServerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateServerResponse)
	err := c.cc.Invoke(ctx, ServerService_UpdateServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) DeleteServer(ctx context.Context, in *DeleteServerRequest, opts ...grpc.CallOption) (*DeleteServerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteServerResponse)
	err := c.cc.Invoke(ctx, ServerService_DeleteServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) StartServer(ctx context.Context, in *StartServerRequest, opts ...grpc.CallOption) (*StartServerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartServerResponse)
	err := c.cc.Invoke(ctx, ServerService_StartServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) StopServer(ctx context.Context, in *StopServerRequest, opts ...grpc.CallOption) (*StopServerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopServerResponse)
	err := c.cc.Invoke(ctx, ServerService_StopServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) GetServerStatus(ctx context.Context, in *GetServerStatusRequest, opts ...grpc.CallOption) (*GetServerStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetServerStatusResponse)
	err := c.cc.Invoke(ctx, ServerService_GetServerStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) StreamServerLogs(ctx context.Context, in *StreamLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogEntry], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ServerService_ServiceDesc.Streams[0], ServerService_StreamServerLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamLogsRequest, LogEntry]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ServerService_StreamServerLogsClient = grpc.ServerStreamingClient[LogEntry]

// ServerServiceServer is the server API for ServerService service.
// All implementations must embed UnimplementedServerServiceServer
// for forward compatibility.
//
// Server Service - Handles game server lifecycle management
type ServerServiceServer interface {
	// Create a new game server on a node
	CreateServer(context.Context, *CreateServerRequest) (*CreateServerResponse, error)
	// Update server configuration
	UpdateServer(context.Context, *UpdateServerRequest) (*UpdateServerResponse, error)
	// Delete a server
	DeleteServer(context.Context, *DeleteServerRequest) (*DeleteServerResponse, error)
	// Start a server
	StartServer(context.Context, *StartServerRequest) (*StartServerResponse, error)
	// Stop a server
	StopServer(context.Context, *StopServerRequest) (*StopServerResponse, error)
	// Get server current status
	GetServerStatus(context.Context, *GetServerStatusRequest) (*GetServerStatusResponse, error)
	// Stream server logs in real-time
	StreamServerLogs(*StreamLogsRequest, grpc.ServerStreamingServer[LogEntry]) error
	mustEmbedUnimplementedServerServiceServer()
}

// UnimplementedServerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedServerServiceServer struct{}

func (UnimplementedServerServiceServer) CreateServer(context.Context, *CreateServerRequest) (*CreateServerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateServer not implemented")
}
func (UnimplementedServerServiceServer) UpdateServer(context.Context, *UpdateServerRequest) (*UpdateServerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateServer not implemented")
}
func (UnimplementedServerServiceServer) DeleteServer(context.Context, *DeleteServerRequest) (*DeleteServerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteServer not implemented")
}
func (UnimplementedServerServiceServer) StartServer(context.Context, *StartServerRequest) (*StartServerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartServer not implemented")
}
func (UnimplementedServerServiceServer) StopServer(context.Context, *StopServerRequest) (*StopServerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StopServer not implemented")
}
func (UnimplementedServerServiceServer) GetServerStatus(context.Context, *GetServerStatusRequest) (*GetServerStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetServerStatus not implemented")
}
func (UnimplementedServerServiceServer) StreamServerLogs(*StreamLogsRequest, grpc.ServerStreamingServer[LogEntry]) error {
	return status.Error(codes.Unimplemented, "method StreamServerLogs not implemented")
}
func (UnimplementedServerServiceServer) mustEmbedUnimplementedServerServiceServer() {}
func (UnimplementedServerServiceServer) testEmbeddedByValue()                       {}

// UnsafeServerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServerServiceServer will
// result in compilation errors.
type UnsafeServerServiceServer interface {
	mustEmbedUnimplementedServerServiceServer()
}

func RegisterServerServiceServer(s grpc.ServiceRegistrar, srv ServerServiceServer) {
	// If the following call panics, it indicates UnimplementedServerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ServerService_ServiceDesc, srv)
}

func _ServerService_CreateServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).CreateServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServerService_CreateServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).CreateServer(ctx, req.(*CreateServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_UpdateServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).UpdateServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServerService_UpdateServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).UpdateServer(ctx, req.(*UpdateServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_DeleteServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).DeleteServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServerService_DeleteServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).DeleteServer(ctx, req.(*DeleteServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_StartServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).StartServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServerService_StartServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).StartServer(ctx, req.(*StartServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_StopServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).StopServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServerService_StopServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).StopServer(ctx, req.(*StopServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_GetServerStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServerStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).GetServerStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServerService_GetServerStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).GetServerStatus(ctx, req.(*GetServerStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_StreamServerLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ServerServiceServer).StreamServerLogs(m, &grpc.GenericServerStream[StreamLogsRequest, LogEntry]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ServerService_StreamServerLogsServer = grpc.ServerStreamingServer[LogEntry]

// ServerService_ServiceDesc is the grpc.ServiceDesc for ServerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ServerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "controller.ServerService",
	HandlerType: (*ServerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateServer",
			Handler:    _ServerService_CreateServer_Handler,
		},
		{
			MethodName: "UpdateServer",
			Handler:    _ServerService_UpdateServer_Handler,
		},
		{
			MethodName: "DeleteServer",
			Handler:    _ServerService_DeleteServer_Handler,
		},
		{
			MethodName: "StartServer",
			Handler:    _ServerService_StartServer_Handler,
		},
		{
			MethodName: "StopServer",
			Handler:    _ServerService_StopServer_Handler,
		},
		{
			MethodName: "GetServerStatus",
			Handler:    _ServerService_GetServerStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamServerLogs",
			Handler:       _ServerService_StreamServerLogs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/controller.proto",
}

const (
	FileService_ListFiles_FullMethodName  = "/controller.FileService/ListFiles"
	FileService_CreateFile_FullMethodName = "/controller.FileService/CreateFile"
	FileService_DeleteFile_FullMethodName = "/controller.FileService/DeleteFile"
	FileService_RenameFile_FullMethodName = "/controller.FileService/RenameFile"
	FileService_MoveFile_FullMethodName   = "/controller.FileService/MoveFile"
	FileService_CopyFile_FullMethodName   = "/controller.FileService/CopyFile"
	FileService_ReadFile_FullMethodName   = "/controller.FileService/ReadFile"
	FileService_WriteFile_FullMethodName  = "/controller.FileService/WriteFile"
	FileService_FileExists_FullMethodName = "/controller.FileService/FileExists"
	FileService_Mkdir_FullMethodName      = "/controller.FileService/Mkdir"
	FileService_ZipFiles_FullMethodName   = "/controller.FileService/ZipFiles"
	FileService_UnzipFiles_FullMethodName = "/controller.FileService/UnzipFiles"
)

// FileServiceClient is the client API for FileService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// File Service - Handles file operations on nodes
type FileServiceClient interface {
	// List files in a directory
	ListFiles(ctx context.Context, in *FileListRequest, opts ...grpc.CallOption) (*FileListResponse, error)
	// Create a file or directory
	CreateFile(ctx context.Context, in *FileCreateRequest, opts ...grpc.CallOption) (*FileOperationResponse, error)
	// Delete a file or directory
	DeleteFile(ctx context.Context, in *FileDeleteRequest, opts ...grpc.CallOption) (*FileOperationResponse, error)
	// Rename a file or directory
	RenameFile(ctx context.Context, in *FileRenameRequest, opts ...grpc.CallOption) (*FileOperationResponse, error)
	// Move a file or directory
	MoveFile(ctx context.Context, in *FileMoveRequest, opts ...grpc.CallOption) (*FileOperationResponse, error)
	// Copy a file or directory
	CopyFile(ctx context.Context, in *FileCopyRequest, opts ...grpc.CallOption) (*FileOperationResponse, error)
	// Read file content
	ReadFile(ctx context.Context, in *FileReadRequest, opts ...grpc.CallOption) (*FileReadResponse, error)
	// Write file content
	WriteFile(ctx context.Context, in *FileWriteRequest, opts ...grpc.CallOption) (*FileOperationResponse, error)
	// Check if file exists
	FileExists(ctx context.Context, in *FileExistsRequest, opts ...grpc.CallOption) (*FileExistsResponse, error)
	// Create directory
	Mkdir(ctx context.Context, in *FileMkdirRequest, opts ...grpc.CallOption) (*FileOperationResponse, error)
	// Zip files/folders
	ZipFiles(ctx context.Context, in *FileZipRequest, opts ...grpc.CallOption) (*FileOperationResponse, error)
	// Unzip archive
	UnzipFiles(ctx context.Context, in *FileUnzipRequest, opts ...grpc.CallOption) (*FileOperationResponse, error)
}

type fileServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFileServiceClient(cc grpc.ClientConnInterface) FileServiceClient {
	return &fileServiceClient{cc}
}

func (c *fileServiceClient) ListFiles(ctx context.Context, in *FileListRequest, opts ...grpc.CallOption) (*FileListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FileListResponse)
	err := c.cc.Invoke(ctx, FileService_ListFiles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) CreateFile(ctx context.Context, in *FileCreateRequest, opts ...grpc.CallOption) (*FileOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FileOperationResponse)
	err := c.cc.Invoke(ctx, FileService_CreateFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) DeleteFile(ctx context.Context, in *FileDeleteRequest, opts ...grpc.CallOption) (*FileOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FileOperationResponse)
	err := c.cc.Invoke(ctx, FileService_DeleteFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) RenameFile(ctx context.Context, in *FileRenameRequest, opts ...grpc.CallOption) (*FileOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FileOperationResponse)
	err := c.cc.Invoke(ctx, FileService_RenameFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) MoveFile(ctx context.Context, in *FileMoveRequest, opts ...grpc.CallOption) (*FileOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FileOperationResponse)
	err := c.cc.Invoke(ctx, FileService_MoveFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) CopyFile(ctx context.Context, in *FileCopyRequest, opts ...grpc.CallOption) (*FileOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FileOperationResponse)
	err := c.cc.Invoke(ctx, FileService_CopyFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) ReadFile(ctx context.Context, in *FileReadRequest, opts ...grpc.CallOption) (*FileReadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FileReadResponse)
	err := c.cc.Invoke(ctx, FileService_ReadFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) WriteFile(ctx context.Context, in *FileWriteRequest, opts ...grpc.CallOption) (*FileOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FileOperationResponse)
	err := c.cc.Invoke(ctx, FileService_WriteFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) FileExists(ctx context.Context, in *FileExistsRequest, opts ...grpc.CallOption) (*FileExistsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FileExistsResponse)
	err := c.cc.Invoke(ctx, FileService_FileExists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) Mkdir(ctx context.Context, in *FileMkdirRequest, opts ...grpc.CallOption) (*FileOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FileOperationResponse)
	err := c.cc.Invoke(ctx, FileService_Mkdir_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) ZipFiles(ctx context.Context, in *FileZipRequest, opts ...grpc.CallOption) (*FileOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FileOperationResponse)
	err := c.cc.Invoke(ctx, FileService_ZipFiles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) UnzipFiles(ctx context.Context, in *FileUnzipRequest, opts ...grpc.CallOption) (*FileOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FileOperationResponse)
	err := c.cc.Invoke(ctx, FileService_UnzipFiles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FileServiceServer is the server API for FileService service.
// All implementations must embed UnimplementedFileServiceServer
// for forward compatibility.
//
// File Service - Handles file operations on nodes
type FileServiceServer interface {
	// List files in a directory
	ListFiles(context.Context, *FileListRequest) (*FileListResponse, error)
	// Create a file or directory
	CreateFile(context.Context, *FileCreateRequest) (*FileOperationResponse, error)
	// Delete a file or directory
	DeleteFile(context.Context, *FileDeleteRequest) (*FileOperationResponse, error)
	// Rename a file or directory
	RenameFile(context.Context, *FileRenameRequest) (*FileOperationResponse, error)
	// Move a file or directory
	MoveFile(context.Context, *FileMoveRequest) (*FileOperationResponse, error)
	// Copy a file or directory
	CopyFile(context.Context, *FileCopyRequest) (*FileOperationResponse, error)
	// Read file content
	ReadFile(context.Context, *FileReadRequest) (*FileReadResponse, error)
	// Write file content
	WriteFile(context.Context, *FileWriteRequest) (*FileOperationResponse, error)
	// Check if file exists
	FileExists(context.Context, *FileExistsRequest) (*FileExistsResponse, error)
	// Create directory
	Mkdir(context.Context, *FileMkdirRequest) (*FileOperationResponse, error)
	// Zip files/folders
	ZipFiles(context.Context, *FileZipRequest) (*FileOperationResponse, error)
	// Unzip archive
	UnzipFiles(context.Context, *FileUnzipRequest) (*FileOperationResponse, error)
	mustEmbedUnimplementedFileServiceServer()
}

// UnimplementedFileServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFileServiceServer struct{}

func (UnimplementedFileServiceServer) ListFiles(context.Context, *FileListRequest) (*FileListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListFiles not implemented")
}
func (UnimplementedFileServiceServer) CreateFile(context.Context, *FileCreateRequest) (*FileOperationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateFile not implemented")
}
func (UnimplementedFileServiceServer) DeleteFile(context.Context, *FileDeleteRequest) (*FileOperationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteFile not implemented")
}
func (UnimplementedFileServiceServer) RenameFile(context.Context, *FileRenameRequest) (*FileOperationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RenameFile not implemented")
}
func (UnimplementedFileServiceServer) MoveFile(context.Context, *FileMoveRequest) (*FileOperationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MoveFile not implemented")
}
func (UnimplementedFileServiceServer) CopyFile(context.Context, *FileCopyRequest) (*FileOperationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CopyFile not implemented")
}
func (UnimplementedFileServiceServer) ReadFile(context.Context, *FileReadRequest) (*FileReadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReadFile not implemented")
}
func (UnimplementedFileServiceServer) WriteFile(context.Context, *FileWriteRequest) (*FileOperationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WriteFile not implemented")
}
func (UnimplementedFileServiceServer) FileExists(context.Context, *FileExistsRequest) (*FileExistsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FileExists not implemented")
}
func (UnimplementedFileServiceServer) Mkdir(context.Context, *FileMkdirRequest) (*FileOperationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Mkdir not implemented")
}
func (UnimplementedFileServiceServer) ZipFiles(context.Context, *FileZipRequest) (*FileOperationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ZipFiles not implemented")
}
func (UnimplementedFileServiceServer) UnzipFiles(context.Context, *FileUnzipRequest) (*FileOperationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UnzipFiles not implemented")
}
func (UnimplementedFileServiceServer) mustEmbedUnimplementedFileServiceServer() {}
func (UnimplementedFileServiceServer) testEmbeddedByValue()                     {}

// UnsafeFileServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FileServiceServer will
// result in compilation errors.
type UnsafeFileServiceServer interface {
	mustEmbedUnimplementedFileServiceServer()
}

func RegisterFileServiceServer(s grpc.ServiceRegistrar, srv FileServiceServer) {
	// If the following call panics, it indicates UnimplementedFileServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FileService_ServiceDesc, srv)
}

func _FileService_ListFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).ListFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_ListFiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).ListFiles(ctx, req.(*FileListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_CreateFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).CreateFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_CreateFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).CreateFile(ctx, req.(*FileCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_DeleteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).DeleteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_DeleteFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).DeleteFile(ctx, req.(*FileDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_RenameFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileRenameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).RenameFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_RenameFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).RenameFile(ctx, req.(*FileRenameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_MoveFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileMoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).MoveFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_MoveFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).MoveFile(ctx, req.(*FileMoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_CopyFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileCopyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).CopyFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_CopyFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).CopyFile(ctx, req.(*FileCopyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_ReadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).ReadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_ReadFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).ReadFile(ctx, req.(*FileReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_WriteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileWriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).WriteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_WriteFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).WriteFile(ctx, req.(*FileWriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_FileExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).FileExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_FileExists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).FileExists(ctx, req.(*FileExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_Mkdir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileMkdirRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).Mkdir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_Mkdir_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).Mkdir(ctx, req.(*FileMkdirRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_ZipFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileZipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).ZipFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_ZipFiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).ZipFiles(ctx, req.(*FileZipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_UnzipFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileUnzipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).UnzipFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_UnzipFiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).UnzipFiles(ctx, req.(*FileUnzipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FileService_ServiceDesc is the grpc.ServiceDesc for FileService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FileService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "controller.FileService",
	HandlerType: (*FileServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListFiles",
			Handler:    _FileService_ListFiles_Handler,
		},
		{
			MethodName: "CreateFile",
			Handler:    _FileService_CreateFile_Handler,
		},
		{
			MethodName: "DeleteFile",
			Handler:    _FileService_DeleteFile_Handler,
		},
		{
			MethodName: "RenameFile",
			Handler:    _FileService_RenameFile_Handler,
		},
		{
			MethodName: "MoveFile",
			Handler:    _FileService_MoveFile_Handler,
		},
		{
			MethodName: "CopyFile",
			Handler:    _FileService_CopyFile_Handler,
		},
		{
			MethodName: "ReadFile",
			Handler:    _FileService_ReadFile_Handler,
		},
		{
			MethodName: "WriteFile",
			Handler:    _FileService_WriteFile_Handler,
		},
		{
			MethodName: "FileExists",
			Handler:    _FileService_FileExists_Handler,
		},
		{
			MethodName: "Mkdir",
			Handler:    _FileService_Mkdir_Handler,
		},
		{
			MethodName: "ZipFiles",
			Handler:    _FileService_ZipFiles_Handler,
		},
		{
			MethodName: "UnzipFiles",
			Handler:    _FileService_UnzipFiles_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/controller.proto",
}
